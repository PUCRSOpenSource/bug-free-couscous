\documentclass[11pt]{IEEEtran}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}

\captionsetup[table]{skip=10pt}

\sloppy

\title{Programação Paralela\\ Trabalho III}

\author{Giovanni Cupertino, Matthias Nunes, \IEEEmembership{Usuário pp12820}}

\begin{document}

\maketitle

\section{Introdução}

	O objetivo do trabalho é desenvolver uma solução que ordene diversos vetores
	utilizando o algoritmo Quick Sort.  Os vetores contém cem mil elementos e
	são, no total, dez mil vetores que estão na ordem inversa de valores indo de
	noventa e nove mil novecentos e noventa e nove na primeira posição até zero
	na ultima posição.  Para a abordagem paralela do trabalho, utilizou-se uma
	implementação híbrida utilizando as ferramentas MPI\@ e OpenMP. Para este 
	trabalho temos um dos processos como mestre, que é responsável por mandar 
	mensagens com os vetores a serem ordenados pelos nós do cluster e reorganizar
	os vetores nas suas posições originais na estrutura. Os outros processos 
	(escravos) recebem os vetores, os ordenam utilizando o algoritmo do quick sort
	e devolvem ao mestre utilizando o OpenMP para a exploração do paralelismo com 
	memória compartilhada dentro do nó.

\section{Análise dos Resultados Obtidos}

	É possível observar que o tempo de resposta não tem grande melhoria com o
	aumento do número de threads e que o tempo de execução do algoritmo mesmo 
	utilizando mais nós do que quando realizado no primeiro trabalho não apresentou
	benefícios com as configurações disponíveis. Os tempos de execução utilizando
	a implementação hibrida não obteve muito sucesso quanto ao tempo de resposta
	e seus tempos com duas ou mais threads se manteve muito proxima degradando a
	eficiência.~\ref{result_table}.

	\begin{table}[H]
		\centering
		\scalebox{0.8}{
			\begin{tabular}{c|r|r|r|r}
				Núcleos & Tempo de Execução(s) & Speed-Up & Speed-Up Ideal & Eficiência \\
				\hline
				1 & 6,59000 & 1,00 & 1 & 1,00 \\
				\hline
				2 & 10,31665 & 0,63877 & 2 & 0,31939 \\
				\hline
				4 & 3,77560 & 1,74542 & 4 & 0,43635 \\
				\hline
				5 & 2,51584 & 2,61941 & 5 & 0,52388 \\
				\hline
				8 & 2,63324 & 2,50262 & 8 & 0,31283 \\
				\hline
				11 & 2,26792 & 2,90575 & 11 & 0,26416 \\
				\hline
				12 & 2,31676 & 2,84449 & 12 & 0,23704 \\
				\hline
				16 & 2,38038 & 2,76846 & 16 & 0,17303 \\
				\hline
				20 & 2,70099 & 2,43985 & 20 & 0,12199 \\
				\hline
				24 & 2,58161 & 2,55267 & 24 & 0,10636 \\
				\hline
				28 & 2,53986 & 2,59463 & 28 & 0,09267 \\
				\hline
				32 & 2,69780 & 2,44273 & 32 & 0,07634 \\
			\end{tabular}
		}
		\caption{Resultados obtidos}
		\label{result_table}
	\end{table}

	\begin{figure}[H]
		\centering
		\includegraphics[width=88mm]{doc/graph.png}
		\caption{Gráfico gerado a partir da tabela}
		\label{fig_graph}
	\end{figure}

	A diferença entre a troca de mensagens pequenas para mensagens maiores 
	podem ser um dos motivos que impactou no tempo de resposta, já que os processos
	passam a receber mensagens maiores e tem que processalas em paralelo com as 
	threads disponíveis e tira o trabalho do mestre em dividir em trabalhos
	menores para serem realizados. Outra questão é que número de núcleos que os nós 
	possuem, para esse tipo de implementação, pode ser ainda muito baixo para que se 
	obtenha resultados mais satisfatórios. 

	O fato de se estar utilizando quatro nós e a biblioteca MPI junto a OpenMP permite 
	uma menor dependência no mestre e que os pacotes de trabalho a serem ordenados sejam
	realizados pelos nós(($8$ núcleos em cada uma das máquinas com capacidade de simular $16$ 
	threads)) que conseguem explorar um paralilismo com memória compartilhadarealizando
	mais de um pedaço da tarefa ao mesmo tempo para cada processo. Quanto a	distribuição de 
	carga que fica a cargo do MPI o algoritmo consegue distribuir ela igualmente parar 
	os processos que estão ativos nos diferentes nós.

\section{Dificuldades Encontradas}

	Foram encontradas dificuldades quanto ao modo de trabalhar do OpenMP que diminuiram após algumas
	pesquisas de como ele funciona, outras dificuldades encontradas foram relativas ao incremento do tempo
	de execução quando comparado aos do trabalho um e quais são as razoões para esse tempo ter aumentado\@.

\end{document}

